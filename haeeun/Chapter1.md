## 들어가며
#### 스프링 컨테이너
- 스프링 런타임 엔진. 
- 설정정보를 참고로 어플리케이션을 구성하는 오브젝트 생성 및 관리. 
- 보통 웹 모듈에서 동작하는 서비스나 서블릿으로 등록해서 사용

#### IoC/DI, 서비스 추상화, AOP
- IoC/DI: 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
- AOP: 어플리케이션 코드에 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화하는 모델

클래스는 스프링 컨테이너 위에서 오브젝트로 만들어져 동작하게 만들고, 코드는 스프링의 프로그래밍 모델을 따라서 작성하고, 엔터프라이즈 기술을 사용할 때는 스프링이 제공하는 기술 API와 서비스를 활용하도록 한다.

* 단순함 - [POJO 프로그래밍]
* 유연성


## 1장 오브젝트와 의존관계
### 1.1 초난감 DAO
---
* DAO(Data Access Object): DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

#### 1.1.1 User
getter / setter
JavaBean : 원래는 비주얼 툴에서 조작 가능한 컴포넌트를 의미. 
보통 두 가지 관례를 따라 만들어진 오브젝트를 의미
- 디폴트 생성자: JavaBean은 파라미터가 없는 디폴트 생성자를 가지고 있어야 한다.
- 프로퍼티: JavaBean이 노출하는 이름을 가진 속성. setter와 getter를 이용해 수정 및 조회 가능

#### 1.1.2 UserDao
JDBC를 이용한 DB 연결 순서
1. DB 연결을 위한 connection을 가져온다.
2. SQL을 담은 Statement (PreparedStatement)를 만든다.
3. 만들어진 Statement를 실행한다.
4. 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮긴다.
5. 작업 중에 생성된 Connection, Statement, ResultSet과 같은 리소스는 작업 종료 후 반드시 닫아준다.
6. JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나 메소드에 throws를 선언해서 예외 발생시 메소드 밖으로 던진다.

#### 1.1.3 main()을 이용한 DAO 테스트 코드
main 메소드를 만들고 그 안에서 UserDao의 오브젝트를 생성해 각 메소드 검증


### 1.2 DAO의 분리
---
#### 1.2.1 관심사의 분리
관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고， 관심이 다른 것은 기능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것

#### 1.2.2 커넥션 만들기의 추출
* 중복 코드의 메소드 추출
* 변경사항에 대한 검증: 리팩토링과 테스트

#### 1.2.3 DB 커넥션 만들기의 독립
* 상속을 통한 확장
추상클래스로 선언 -> 본 소스코드를 수정하지 않아도 메소드를 원하는 방식으로 확장한 후 기능 사용 가능

* 템플릿 메소드 패턴 : 슈퍼클래스에 기본적인 로직의 흐름(커넥션 가져오기. SQL 생성. 실행， 반환)을 만들고， 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 펼요에 맞게 구현해서 사용하도록 하는 방법 (상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법)
* 팩토리 메소드 패턴 : 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 방법 (서브 클래스에서 오프젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 팩토리 메소드)

* 디자인 패턴 : 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 이쓴 재사용 가능한 솔루션. 객체지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법은 대부분 클래스 상속과 오브젝트 합성 두가지 구조로 정리된다. 패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적 또는 의도다. 

템플릿 메소드 패턴과 팩토리 메소드 패턴의 단점은 상속을 사용하고 있다는 것. 상속을 사용할 경우 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 수정해야 할 수도 있다.


### 1.3 DAO의 확장
---
#### 1.3.1 클래스의 분리
상속관계가 아닌 완전히 독립적인 클래스로 만든다. 서브클래스는 상속이 아니라 new를 이용해 클래스의 오브젝트를 만들어두고 사용한다.
- 문제1. 클래스를 분리한 경우에도 상속을 이용했을 때와 마찬가지로 서브클래스에서 전체 메소드 코드를 일일이 변경해야 한다.
- 문제2. 슈퍼클래스의 메소드를 구체적으로 알고 있어야 하고 슈퍼클래스 자체를 다시 수정해야 한다. 

#### 1.3.2 인터페이스의 도입
인터페이스 : 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춘다. 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 상관없다. 인터페이스는 어떤 일을 하겠다는 기능만 정의해 놓은 것. 

#### 1.3.3 관계설정 책임의 분리
오브젝트와 오브젝트 사이의 관계를 설정해주어야 함. 한 오브젝트(클래스)가 관계를 설정하는 인터페이스 외에는 어떤 클래스와도 의존 관계가 만들어지지 않도록 만들어야 한다. 코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다(다형성). 
인터페이스를 도입하고 클라이언트(인터페이스를 사용하는 오브젝트)의 도움을 얻는 방법은 상속을 사용했을 때보다 유연하다. 인터페이스를 사용하기만 하면 다른 DAO 클래스에도 인터페이스 구현 클래스들을 그대로 적용할 수 있기 때문이다. DAO가 아무리 많아져도 DB 접속 방법에 대한 관심을 한 군데에 집중되게 하고 DB 접속 방법을 변경해야 할 때도 한 곳의 코드만 수정하면 된다.

#### 1.3.4 원칙과 패턴
* 개방 폐쇄 원칙(OCP) : ‘클래스나 모률은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다
* 객체지향 설계 원칙 (SOLID)
    - SRP(The Single Responsibility Principle): 단일 책임 원칙
    - OCP(The Open Closed Principle): 개방 폐쇄 원칙
    - LSP(The Liskov Substitution Principle): 리스코프 치환 원칙
    - ISP(The Interface Segregation Principle): 인터페이스 분리 원칙
    - DIP(The Dependency Inversion Principle): 의존관계 역전 원칙
* 높은 응집도와 낮은 결합도 
    - 높은 응집도: 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 었다. 즉 변경이 일어날 때 모률의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있다.
    - 낮은 결합도: 하나의 변경이 발생할 때 마치 파문이 이는 것처럼 여타 모률과 객체로 변경에 대한 요구가 전파되지 않는 상태 (결합도: 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도)
* 전략 패턴: 자신의 기능 맥락에서, 필요에 따라 변 경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고， 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 부분을 인터페이스로 정의하고, 이를 구현한 클래스를 분리했다. 컨텍스트를 사용하는 클라이언트는 컨텍스트가 사용할 전략(인터페이스를 구현한 클래스)을 컨텍스트의 생성자 등을 통해 제공하는 것이 일반적.


### 1.4 제어의 역전(IoC, Inversion of Control)
---
#### 1.4.1 오브젝트 팩토리
* 팩토리 : 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것
        오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 분리하려는 목적
        어플리케이션의 컴포넌트 역할을 하는 오브젝트와 어플리케이션의 구조를 결정하는 오브젝트를 분리

#### 1.4.2 오브젝트 팩토리의 활용
여러 개의 DAO를 생성하는 메소드가 추가된 경우 오브젝트 생성 코드가 중복된다. 중복문제를 해결하기 위해 분리 필요.

#### 1.4.3 제어권의 이전을 통한 제어관계 역전
* 제어의 역전 : 프로그램의 제어 흐름 구조가 뒤바뀌는 것. 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하거나 생성하지 않는다. 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임한다. main() 같은 엔트리 포인트를 제외하면 모든 오브젝트는 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.
    ex) 
    - 서블릿: 서블릿에 대한 제어 권한을 가진 컨테이너가 적적한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다.
    - 디자인 패턴 (템플릿 메소드 패턴): 제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용되도록 한다.
    - 프레임워크

cf) 라이브러리와 프레임워크의 차이점
- 라이브러리 : 라이브러리를 사용하은 어플리케이션 코드는 어플리케이션 흐름을 직접 제어한다. 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용한다.
- 프레임워크 : 어플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크 위에 개발한 클래스를 등록하고 프레임워크가 흐름을 주도하는 중에 개발자가 만든 어플리케이션 코드를 사용하게 한다.


### 1.5 스프링의 IoC
---
#### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
1. 애플리케이션 컨텍스트와 설정 정보
* Bean: 스프링이 제어권을 가지고 직접 만들고 관계를 부여한느 오브젝트. 오브젝트 단위의 애플리케이션 컴포넌트이자 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트.
* Bean Factory: 빈의 생성과 관계 설정 같은 제어를 담당하는 IoC오브젝트
* Application context: IoC 방식을 따라 만들어진 일종의 빈 팩토리. 별도의 정보를 참고해서 빈(오브젝트)의 생성, 관계설정 등의 제어 작업 총괄.

2. DaoFactory를 사용하는 애플리케이션 컨텍스트
빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스에 @Configuration, 오브젝트를 만들어 주는 메소드에 @Bean 어노테이션 추가 => 어플리케이션 컨텍스트가 IoC 방식의 기능을 제공할 때 사용할 설정 정보
어플리케이션 컨텍스트는 ApplicationContext 타입의 오브젝트. 
ApplicationContext를 구현한 클래스 중 DaoFactory처럼 @Configuration이 붙은 자바 코드를 설정정보로 사용하려면 AnnotationConfigApplicationContext를 이용하고, 어플리케이션 컨텍스트를 만들 때 생성자 파라미터로 DaoFactory 클래스를 넣어준다.

#### 1.5.2 애플리케이션 컨텍스트의 동작방식
* 어플리케이션 컨텍스트 : IoC 컨테이너, 스프링 컨테이너, 빈 팩토리. ApplicationContext 인터페이스를 구현하는데, ApplicationContext는 BeanFactory 인터페이스를 상속했으므로 일종의 빈 팩토리임. DaoFactory가 DAO 오브젝트를 생성하고, DB 생성 오브젝트와 관계를 맺어주는 제한적인 역할을 하는 반면 어플리케이션 컨텍스트는 어플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계 설정 담당. 코드가 아닌 별도의 설정정보를 통해 오브젝트 생성정보와 견관관계 정보를 얻는다. 외부 오브젝트 팩토리에 그 작업을 위임하고 그 결과를 가져다가 사용하는 경우도 있다.

* @Configuration이 붙은 DaoFactory는 어플리케이션 컨텍스트가 활용하는 IoC 설정정보로 내부적으로는 어플리케이션 컨텍스트가 DaoFactory의 userDao() 메소드를 호출해서 오브젝트를 가져온 것을 클라이언트가 getBean()으로 요청할 때 전달해줌. DaoFactory 클래스를 설정정보로 등록해두고 @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다. 클라이언트가 getBean()을 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾아 빈을 생성하는 메소드를 호출해서 오브젝트를 생성한 후 클라이언트에 반환.

* 장점 
    - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
        - IoC를 적용한 오브젝트가 추가되도 일관된 방식으로 원하는 오브젝트를 가져올 수 있다.
        - 단순한 방법으로 어플리케이션 컨텍스트가 사용할 IoC 설정정보를 만들 수 있다.
    - 어플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
        - 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있음
        - 자동생성, 오브젝트에 대한 후처리, 정보 조합, 설정 방식의 다변화, 인터셉팅 등 다양한 기능 제공
        - 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공
    - 어플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
        - getBean()
        - 타입, 특별한 어노테이션 설정되어 있는 빈 검색 가능

#### 1.5.3 스프링 IoC의 용어 정리
* 빈 (Bean) : 스프링이 IoC 방식으로 관리하는 오브젝트. 스프링이 직접 생성과 제어를 담당하는 오브젝트만 빈.
* 빈 팩토리 (Bean Factory) : 스프링의 IoC를 담당하는 핵심 컨테이너. 빈 등록, 생성, 조회, 반환 등 빈을 관리하는 기능. 보통 빈 팩토리를 확장한 어플리케이션 컨텍스트 이용.
* 어플리케이션 컨텍스트 (Application Context) : 빈 팩토리를 확장한 IoC 컨테이너. 빈 팩토리의 기능에 스프링이 제공하는 부가 서비스 추가 제공. ApplicationContext는 BeanFactory를 상속함.
* 설정정보/설정 메타정보 (Configuration metadata) : 스프링의 설정정보는 어플리케이션 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보. 보통 IoC 컨테이너에 의해 관리되는 어플리케이션 오브젝트를 생성하고 구성할 때 사용.
* 컨테이너 (IoC container) : IoC 방식으로 빈을 관리한다는 의미에서 어플리케이션 컨텍스트나 빈 팩토리를 컨테아너 또는 IoC 컨테이너라고 부름. 
* 스프링 프레임워크 : 스프링이 제공하는 모든 기능을 통틀어 말함

### 1.6 싱글톤 레지스트리와 오브젝트 스코프
---
#### cf) 오브젝트의 동일성과 동등성
* 동일성(identity): 두 개의 오브젝트가 완전히 동일한 오브젝트인가. 오브젝트는 하나만 존재하고, 두 개의 오브젝트의 레버런스 변수를 가짐. (== 연산자로 비교) 
* 동등성(equaility): 동일한 정보를 담고 있는 오브젝트인가. 두 개의 각기 다른 오브젝트가 메모리상에 존재함. (equals() 메소드로 비교)
* 동일한 오브젝트는 동등하지만, 반대는 항상 참은 아니다.

스프링 어플리케이션 컨텍스트는 여러 번 빈을 요청해도 동일한 오브젝트를 돌려준다. 

#### 1.6.1 싱글톤 레지스트리로서의 어플리케이션 컨텍스트
* 어플리케이션 컨텍스트 : IoC 컨테이너인 동시에 싱글톤을 저장하고 관리하는 싱글톤 레지스트리. 

1. 서버 애플리이션과 싱글톤
스프링은 대부분 하나의 요청을 처리하기 위해 데이터 액세스 로직, 서비스 로직, 비즈니스 로직, 프레젠테이션 로직 등 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조로 이뤄져 있다. 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용할 경우 부하가 커진다. 따라서 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 
```
싱글톤 패턴
서블릿 클래스 당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다. 어플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용함.
```
2. 싱글톤 패턴의 한계
    - 클래스 밖에서 오브젝트를 생성하지 못하도록 생성자를 private으로 만듦  
    - 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 static 필드 정의
    - static 팩토리 메소드인 getInstance()를 만들고 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 static 필드에 저장되거나 static 필드의 초기값으로 오브젝트를 미리 만들어둠
    - 오브젝트가 한 번(싱글톤) 만들어지고 난 후에는 getInstance()로 이미 만들어져 static 필드에 저장해둔 오브젝트를 넘겨줌

* 문제점
    - private 생성자를 가지고 있어 상속 불가
    - 테스트 어려움
    - 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장 불가
    - 싱글톤 사용은 전역 상태를 만들 수 있어 바람직하지 않음

3. 싱글톤 레지스트리
* 싱글톤 레지스트리 : 자바의 기본적인 싱글톤 패턴 구현 방식은 여러 단점이 있기 때문에 스프링이 직접 제공하는 싱글톤 형태의 오브젝트를 만들고 관리하는 기능. 스프링 컨테이너는 싱글톤을 생성, 관리, 공급하는 싱글톤 관리 컨테이너이기도 함.
* 장점 : 평범한 자바 클래스를 싱글톤으로 활용하게 해줌. 객체지향적인 설계 방식과 원칙, 디자인 패턴 적용에 제약이 없음.

#### 1.6.2 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경에서는 여러 스레드가 동시에 접근하여 사용할 수 있으므로 상태 관리에 주의해야 함. 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우 인스턴스의 필드 값을 변경하고 유지하는 상태유지(stateful) 방식이 아닌 무상태(stateless)방식으로 만들어져야 한다.
읽기 전용 정보와, 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도로는 인스턴스 변수 사용 가능. 스프링이 한 번 초기화하고 나면 이후에는 수정되지 않기 때문에 멀티스레드 환경에서 사용해도 문제 없음. 읽기 전용의 경우 static final이나 final로 선언하는 것이 좋음.

#### 1.6.3 스프링 빈의 스코프
스프링이 관리하는 오브젝트인 빈이 생성되고, 존재하고, 적용되는 범위.
* 싱글톤 스코프 : 스프링 빈의 기본 스코프. 컨테이너 내에 한 개의 오브젝트만 만들어져 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지됨.
* 프로토타입 스코프 : 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트 생성
* 요청 스코프 : HTTP 요청 생성시 마다 생성됨
* 세션 스코프


### 1.7 의존관계 주입(DI)
---
#### 1.7.1 제어의 역전(IoC)과 의존관계 주입
스프링 IoC 기능의 대표적인 동작 원리는 주로 의존관계 주입이라고 불림. 
Dependency Injection : 오브젝트 레퍼런스를 외부로붕터 제공(주입) 받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어진다. 

#### 1.7.2 런타임 의존관계 설정
1. 의존관계
두 개의 클래스 / 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해야 한다. (누가 누구에게 의존하는 관계이다.)  

ex (A가 B에 의존하고 있는 경우)
```
A ----> B
```
의존: 의존 대상(B)이 변하면 A에 영향을 미친다.

2. UserDao의 의존관계
3. UserDao의 의존관계 주입





** [] : 추후에 찾아볼 것