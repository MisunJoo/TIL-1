# 오브젝트와 의존관계

스프링이 자바에서 가장 중요하게 가치를 두는 것이 바로 객체지향 프로그래밍이 가능한 언어라는 점이다. 그래서 스프링이 가장 관심을 많이 두는 대상은 오브젝트이다. 그래서 애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와의 관계를 맺고, 사용, 소멸까지의 전 과정에 관심을 가져야 한다.

이런 오브젝트의 관심은 오브젝트의 기술적인 특징과 사용 방법을 넘어서 오브젝트의 설계로 발전하게 되고 다음과 같은 여러 가지 응용 기술과 지식이 요구된다.
* 객체지향 설계의 기초와 원칙
* 다양한 목적을 위해 재활용 가능한 설계 방법인 디자인 패턴
* 좀 더 깔끔한 구조가 되도록 지속적으로 개선해나가는 리팩토링
* 오브젝트가 기대한 대로 동작하고 있는지를 효과적으로 검증하는 데 쓰이는 단위 테스트

### 자바빈
원래 비주얼 툴에서 조작 가능한 컴포넌트였다. 점점 인기를 잃어갔지만 자바빈 스타일의 오브젝트를 사용하는 오픈소스 기술을 통해 계속 이어져 왔다. 이제는 비주얼 컴포넌트라기 보다는 다음 두 가지 관례를 따라 만들어진 오브젝트이다.
* 디폴트 생성자
  * 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문이다.
* 프로퍼티
  * 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다(getter, setter).

### JDBC를 이용하는 작업의 일반적인 순서
* DB 연결을 위한 Connection을 가져온다.
* SQL을 담은 statement(또는 PreparedStatement)를 만든다.
* 만들어진 Statement를 실행한다.
* 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
* 작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아준다.
* JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다.

### 템플릿 메소드 패턴, 팩토리 메소드 패턴
##### 템플릿 메소드 패턴

상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다. 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.

템플릿 메소드는 제어의 역전이라는 개념을 활용해 문제를 해결할 수 있는 디자인 패턴이다.

#####팩토리 메소드 패턴

팩토리 메소드 패턴도 템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능은 확장하게 하는 패턴이다.  

슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트(주로 인터페이스)를 가져와 사용한다. 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정(new를 이용해 클래스를 만드는 것)할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.

### 전략 패턴
[전략 패턴](https://github.com/sdh2398/TIL/blob/master/Design_Pattern/strategy_pattern.md)


### 라이브러리, 프레임워크
* 라이브러리
  * 라이브러리를 사용하는 애플리케이션 코드는 흐름을 직접 제어한다.
  * 동작하는 중에 필요한 기능이 있을 경우 능동적으로 라이브러리를 사용한다.
* 프레임워크
  * 애플리케이션 코드가 프레임워크에 의해 사용된다.
  * 프레임워크에 개발한 클래스를 등록해두고, 프레임워크가 애플리케이션 코드를 사용하도록 만드는 방식이다.
  * 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다.

### 애플리케이션 컨텍스트
빈을 등록하고, 생성하고, 조회하고, 돌려주고, 그 외에 부가적인 빈을 관리하는 스프링 IoC의 핵심 컨테이너인 빈 팩토리를 확장한 IoC 컨테이너이다. 빈 팩토리의 기능 외에 각종 부가 서비스를 추가로 제공한다.

##### 애플리케이션 컨텍스트를 사용했을 때 장점
* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
* 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
* 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공해준다.

### 싱글톤 패턴
어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수(주로 하나)로 강제하는 패턴이다. 이렇게 만들어진 클래스는 전역적으로 접근이 가능하다. 단일 오브젝트만 존재해야 하고, 주로 여러 곳에서 공유하는 경우에 주로 사용한다.

#### 기존 싱글톤 패턴의 한계
* private 생성자를 갖고 있기 때문에 상속을 할 수 없다.
  * private 생성자를 가진 클래스는 다른 생성자가 없으면 상속이 불가능하다.
  * 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다.
  * 애플리케이션 로직을 담고 있는 일반 오브젝트의 경우 싱글톤일 때 객체지향적인 설계의 장점을 적용하기 어렵다.
  * 상속과 다형성 같은 객체지향의 특징이 적용되지 않는 스태틱 필드와 메소드를 사용한다.
* 싱글톤은 테스트하기 힘들다
  * 만들어지는 방식이 제한적이어서 목 오브젝트 등으로 대체하기 힘들다.
* 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
  * 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤임에도 하나 이상 만들어질 수 있다.
  * 여러 개의 JVM에 분산돼서 설치가 되는 경우 각각 독립적으로 오브젝트가 생겨서 싱글톤으로서 가치가 떨어진다.
* 싱글톤 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
  * 싱글톤의 스태틱 메소드를 이용해 어디서든 사용할 수 있어서 전역상태가 되기 쉽다.
  * 아무나 접근하고 수정하고 공유할 수 있는 전역 상태는 객체지햐에서 권장하지 않는다.
  * 차라리 스태틱 필드와 메소드로만 구성된 클래스를 사용하는게 낫다.

### 싱글톤 레지스트리
스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트로 사용되는 것을 적극 지지한다. 하지만 여러가지 직접 구현은 여러 가지 단점이 있어서, 스프링이 직접 싱글톤으로 관리하는 기능을 제공하는데, 그것이 바로 싱글톤 레지스트리다.

싱글톤은 멀티스레드 환경에서 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야 한다.

### 스프링 빈의 스코프
스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위를 스프링에서는 빈의 스코프(scope)라고 한다. 기본 스코프는 싱글톤이다.

* 싱글톤 스코프
  * 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.
  * 대부분의 빈은 싱글톤 스코프를 갖는다.
* 프로토타입(prototype) 스코프
  * 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다.
* 요청(request) 스코프
  * 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성된다.
* 세션(session) 스코프
  * 웹의 세션과 스코프가 유사하다.

### 의존관계 주입(DI)
IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라서 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다. 그래서 스프링이 제공하는 IoC 방식의 핵심을 짚어주는 DI라는, 좀더 의도가 명확한 이름을 사용하기 시작했다.

DI는 오브젝트를 다른 오브젝트에 주입할 수 있는게 아니고, 오브젝트 레퍼런스를 외부로부터 제공(주입) 받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계까지 만들어주는 것이 핵심이다.

하지만 단지 외부에서 파라미터로 넘겨줬다고 해서 다 DI가 아니다. 파라미터가 특정 클래스 타입으로 고정되어 있다면 DI가 일어날 수 없고, 인터페이스 타입의 파라미터를 통해 주입받아야 한다.

### 의존관계 주입, 의존관계 검색
의존관계 주입은 주입을 받는 쪽과 주입되는 쪽 둘다 빈이어야 한다. 하지만, 의존관계 검색 방식에서 검색하는 오브젝트는 스프링의 빈일 필요가 없다. 주입되는 쪽만 스프링 빈이면 된다.

### DI 기술의 장점
객체지향 설계와 프로그래밍 원칙을 따랐을 때의 장점을 얻을 수 있다.
* 코드에서 런타임 클래스에 대한 의존관계가 나타나지 않는다.
* 인터페이스를 통해 결합도가 낮아진다.
* 다른 책임을 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않는다.
* 변경을 통한 다양한 확장 방법에는 자유롭다.
