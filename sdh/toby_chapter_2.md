# 테스트
스프링이 개발자에게 제공하는 가장 중요한 가치는 객체지향과 테스트이다.

애플리케이션은 계속 변하고 복잡해져 간다. 그 변화에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면, 두 번째 전략은 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술이다.

테스트는 스프링을 학습하는 데 있어 가장 효과적인 방법의 하나다. 테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.

### 웹을 통한 DAO 테스트 방법의 문제점
웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이지만, DAO에 대한 테스트로서 단점이 많다. DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어 기능을 다 만들고나서 테스트가 가능하다. 테스트를 하는 중에 어디서 문제가 발생했는지 찾아내야하는 수고도 필요하다.

### 작은 단위의 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 한꺼번에 많은 테스트를 몰아서 하면 수행 과정도 복잡해지고, 오류가 발생했을 때의 원인을 찾기 힘들어진다. 따라서 테스트는 가능하면 작은 단위로 쪼개 집중해서 할 수 있어야 한다. 관심사의 분리가 테스트에도 적용된다.

작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(unit test)라고 한다. 여기서 말하는 단위는 정해진 건 아니고 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다. 일반적으로 단위는 작을수록 좋다.

초기 등록부터 시작해서 로그인, 로그아웃까지 전 과정을 하나로 묶어서 테스트를 할 필요가 언젠가는 생긴다. 이 때 단위별로 테스트를 진행해서 단위별로 검증을 마치면 오류를 잡기 훨씬 나을 것이다.

### main() 메소드로 Test할때의 문제점
UserDaoTest를 할 때 UI까지 동원되는(서버를 띄우고 폼창에 정보를 입력하는 작업들) 수동 테스트에 비해 장점이 많지만 만족스럽지 못한 부분도 있다.
* 수동 확인 작업의 번거로움
  * 테스트를 수행하는 과정과 입력 데이터의 준비를 모두 자동으로 진행하도록 만들어졌지만, 여전히 사람의 눈으로 확인하는 과정이 필요하다.
  * 데이터를 저장하고 조회했을 때 올바른 값인지 테스트 코드는 확인 해주지 않고 콘솔에 값만 출력해줄 뿐이다.
  * 몇 가지 필드의 값에 대한 등록과 조회면 괜찮지만 검증해야하는 양이 많아지면 문제가 생긴다.
* 실행 작업의 번거로움
	* 아무리 main() 메소드가 간단히 실행할 수 있다더라도 DAO가 수백 개가 되고 main() 메소드도 그만큼 만들어진다면, 전체 기능 테스트를 위해 수백 번 main()메소드를 실행시켜야 한다.

### 테스트의 효율적인 수행과 결과 관리
자바에는 단순하면서도 실용적인 테스트를 위한 도구가 여러 가지 존재한다. 그중에서도 JUnit은 자바에서 유명한 테스트 지원 도구다. 이 JUnit 역시 프레임워크이기 때문에 프레임워크의 기본 동작원리인 제어의 역전을 통해 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다.

테스트가 main()메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이기 때문에 JUnit 프레임워크가 요구하는 조건 두 가지를 따라야 한다.
* 메소드가 public으로 선언돼야 한다.
* 메소드에 @Test라는 애노테이션을 붙여줘야 한다.

JUnit 프레임워크를 이용해 만든 테스트 메소드를 실행하도록 하려면 스프링 컨테이너와 마찬가지로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다. 어디에든 main() 메소드를 추가하고, 그 안에 JUnitCore 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어주면 된다. 메소드 파라미터에는 @Test 메소드를 가진 클래스의 이름을 넣어준다.
```
public static void main(String[] args) {  
  JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```

### 테스트 결과의 일관성
반복적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.

### 포괄적인 테스트
포괄적인 테스트를 만들어두는 편이 훨씬 안전하고 유용하다. 특히 평소에는 정상적으로 잘 동작하는 것처럼 보이지만 막상 특별한 상황이 되면 엉뚱하게 동작하는 코드도 테스트를 안해봤다면 나중에 원인을 찾기 힘들 수 있다. 종종 단순하고 간단한 테스트가 치명적인 실수를 피할 수 있게 해주기도 한다.

개발자가 테스트를 직접 만들 때 하는 실수가 성공하는 테스트만 골라서 만드는 것이다. 개발자는 잘 돌아가는 케이스만 상상하면서 코드를 만드는 경우가 일반적이어서 스프링의 창시자인 로드 존슨은 "항상 네거티브 테스트를 먼저 만들라"는 조언을 했다.

### 테스트 주도 개발
만들고자하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 테스트 주도개발(TDD)이라고 한다.

 TDD는 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있다. "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"는 것이 TDD의 기본 원칙이다. 이 원칙을 따르면 모든 코드는 테스트가 검증된 것이라고 볼 수 있다.

TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 최대한 짧게 가져가도록 권장한다. 이렇게 코드를 만들어 테스트 하는 간격이 짧은 장점 때문에 개발한 코드의 오류를 빨리 발견할 수 있다.

### JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식
* 테스트 클래스에서 @Test가 붙은 public, void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
* 테스트 클래스의 오브젝트를 하나 만든다.
* @Before가 붙은 메소드가 있으면 실행한다.
* @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
* @After가 붙은 메소드가 있으면 실행한다.
* 나머지 테스트 메소드에 대해서도 반복한다.
* 모든 테스트의 결과를 종합해서 돌려준다.

기억해야할 사항은 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다는 것이다. 한번 만들어진 테스트 클래스 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다. 이렇게 하는 이유는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 한다. 덕분에 인스턴스 변수도 매번 초기화가 되기 때문에 부담없이 사용할 수 있다.

### 스프링 테스트 적용
테스트를 하기 위해선 애플리케이션 컨텍스트를 만들고 빈을 가져다가 써야한다. 하지만 매번 테스트마다 애플리케이션 컨텍스트를 만들면 모든 싱글톤 빈 오브젝트를 초기화 하기 때문에 적지 않은 시간이 걸릴 수 있다. 그래서 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 테스트 컨텍스트의 지원을 받으면 간단한 애노테이션 설정만으로 테스트에 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.
```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class Test {
    @Autowired
    private ApplicationContext context;
}
```
* @RunWith : JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다.
  * SpringJUnit4ClassRuner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.
* @ContextConfiguration : 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한다.

스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해준다. 일종의 DI라고 볼 수 잇지만, 애플리케이션 오브젝트 사이의 관계를 관리하기 위한 DI와는 성격이 조금 다르다.

다른 클래스일지라도 같은 설정파일을 사용하는 경우에도 애플리케이션 컨텍스트는 공유하게 된다. 다른 설정파일을 사용하도록 만들면 설정파일의 종류만큼 애플리케이션 컨텍스트를 만들고, 같은 설정파일을 지정한 테스트끼리 공유하게 해준다.

### DI와 테스트
개발하고 있는 시스템에서 인터페이스필요 없이 항상 구체적인 클래스만 사용할 것이라고 할 때도 굳이 인터페이스를 사용하고 DI를 통해 주입 받아야 하는 이유가 있다.
* 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
* 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있다.
* 효율적인 테스트를 손쉽게 만들기 위해서 DI를 적용해야 한다.

### DI를 이용한 테스트 방법 선택
* 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려
  * 이 방법이 가장 빠르고 간결하다
  * 테스트를 위해 필요한 오브젝트의 생성과 초기화가 단순하다면 이 방법을 가장 먼저 고려
* 오브젝트와 복잡한 의존관계를 갖고 있는 경우
  * 스프링의 설정을 이용한 DI 방식의 테스트를 이용
  * 테스트에서 애플리케이션 컨텍스트를 사용하는 경우 전용 설정파일을 만들어 사용
* 테스트 설정을 따로 만들었어도 예외적인 의존관계를 강제로 구성해야 할 경우
  * DI받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트
  * 테스트 메소드나 클래스에 @DirtiesContext 애노테이션을 붙여야 한다.

### 학습 테스트
자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성할 때가 있는 이런 테스트를 학습 테스트라고 한다.

학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것이다. 기능에 대한 검증 목적이 아니고, 자신이 테스트를 만들려고 하는 기술이나 기능에 대해 얼마나 제대로 이해하고 있는지, 그 사용 방법을 바로 알고 있는지를 검증하려는 게 목적이다.
학습테스트의 장점
* 다양한 조건에 따른 기능을 손쉽게 확인해 볼 수 있다.
* 학습 테스트 코드를 개발 중에 참고할 수 있다.
* 프레임워크나 제품을 업그레이드 할 때 호환성 검증을 해준다.
* 테스트 작성에 대한 좋은 훈련이 된다.
* 새로운 기술을 공부하는 과정이 즐거워진다.

### 버그 테스트
QA팀이나 사용자가 버그가 있다고 요청이 들어왔을 때, 무턱대고 코드를 뒤져가면서 수정하려고 하는 것보다 버그 테스트를 만들어보는 편이 유용하다. 버그 테스트는 버그가 원인이 되서 테스트가 실패하도록 코드를 만드는 것이다. 그리고 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정한다.
버그 테스트의 장점
* 테스트의 완성도를 높여준다.
  * 기존 테스트에서 검증하지 못했던 부분에 대해 불충분했던 테스트를 보완해준다.
* 버그의 내용을 명확하게 분석하게 해준다.
  * 문제의 원인을 명확하게 알아야 하기 때문에 버그를 좀 더 효과적으로 분석할 수 있다.
  * 테스트 코드를 만들면서 오류를 발생시키는 값의 범위가 어떤 것인지 분석할 수 있다.
  * 테스트의 중요한 기법 중의 하나인 동등분할이나 경계값 분석을 적용해 볼 수 있다.
    * 동등분할 : 같은 결과를 내는 값의 범위를 구분(예를 들어 true, false, 예외상황)해서 각 대표 값으로 테스트를 하는 방법
    * 경계값 분석 : 동등분할 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값(0이나 그 주변 값 또는 정수의 최대, 최소 값)을 테스트 하는 방법
* 기술적인 문제를 해결하는 데 도움이 된다.
  * 원인이 무엇인지 파악하기 힘들거나 코드와 설정 등을 봐도 문제가 없다고 느낄 때 동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 된다.
  * 외부의 전문가나 포럼, 메일링 리스트 등 커뮤니티의 도움을 받을 때도 도움이 된다.
