# 1장 오브젝트와 의존관계
- 스프링
  - 자바
    - 객체지향 프로그래밍
      - 오브젝트

## 1.1 초난감 DAO
- DAO
  - Data Access Object
  - DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

#### 1.1.1 User
- 사용자 정보를 저장할 User 클래스
  - 프로퍼티
  - setter & getter
- 정보가 실제로 보관될 DB의 테이블도 User 클래스와 동일하게 구성
- 자바빈(JavaBean)
  - 두 가지 관례를 따라 만들어진 오브젝트, 빈이라고도 함.
    - 디폴트 생성자
      - 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다.
      - 툴이나 프레임 워크에서 리플렉션율 이용해 오브젝트를 생성하기 때문에 필요하다.
    - 프로퍼티
      - 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다.
      - 프로퍼티는 수정자 메소드(setter)와 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다.

#### 1.1.2 UserDao
- 시용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스
- 이 클래스의 문제점은?
  - 잘 동작하지만 리팩토링이 필요하다. 왜?
  - 객체지향 설계의 원칙과는 무슨 상관이 있을까?
- 스프링을 공부한다는 건 바로 이런 문제 제기와 의문에 대한 답을 찾아나가는 과정이다.

#### 1.1.3 main()을 이용한 DAO 테스트 코드
- 셀프 테스트용 main 메소드

## 1.2 DAO의 분리

#### 1.2.1 관심사의 분리
- 오브젝트의 설계와 이를 구현한 코드는 끊임없이 변한다.
- 미래의 변화를 어떻게 대비할 것인가?
  - 객체를 설계할 때 가장 염두해야 할 사항
  - 변화의 폭을 최소화
    - 분리와 확장을 고려한 설계
- 변회는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다.
  - DB 접속용 암호를 변경하려고 DAO 클래스 수백 개를 모두 수정해야 한다면?
  - 트랜잭션 기술을 다른 것으로 바꿨다고 비즈니스 로직이 담긴 코드의 구조를 모두 변경해야 한다면?
  - 다른 개발자가 개발한 코드에 변경이 일어날 때마다 내가 만든 클래스도 함께 수정을 해줘야 한다면?
- 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과 적으로 집중할 수 있게 만들어야 한다.

#### 1.2.2 커넥션 만들기의 추출
- 1.1.2 UserDao의 관심사항
  - DB 연결
  - SQL 문장을 담을 Statement를 만들고 실행하는 것
  - 작업이 끝나면 오브젝트를 닫는 것
  - 예외처리 등등
- 앞의 UserDao 클래스는 스파게티 코드
  - 어떻게 해결할까?
    - 메소드 추출 기법
      - 중복 코드의 메소드 추출
      - 특정 관심사항이 담긴 코드를 별도의 메소드로 분리
- 리팩토링
  - 기존의 코드톨 외부의 동작방식에는 변화 없이 내부 구조톨 변경해서 재구성하는 작업 또는 기술
  - 추천 도서 : 리팩토링(마틴 파율러, 켄트 백 공저)

#### 1.2.3 DB 커넥션 만들기의 독립
- 변화에 대응하는 수준을 넘어 반기는 DAO?
  - UserDao 소스코드를 N 사와 D 사에 제공해주지 않고도 고객 스스로 원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까?
    - 상속을 통한 확장
      - 기존 UserDao 코드를 한 단계 더 분리
      - UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만들어놓는다.
      - 기존에는 같은 클래스에 다른 메소드로 분리됐던 DB 커넥션 연결이라는 관심을 이번에는 상속을 통해 서브클래스로 분리
      - ![image](https://user-images.githubusercontent.com/36880294/54139238-790fae80-4464-11e9-85a5-cae8817e27c7.png) 
    - 클래스 계층구조를 통해 두 개의 관심이 독립적으로 분리
      - 어떻게 데이터를 등록하고 가져올 것인가? --> UserDao
      - DB 연결 방법은 어떻게 할 것인가? --> NUserDao, DUserDao
    - 이제 UserDao는 단순히 변경이 용이하다라는 수준을 넘어서 손쉽게 확장된다라고 말할 수도 있게 됐다.
- 디자인 패턴(Design Patterns)
  - 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용활 수 있는 재사용 가능한 솔루션
  - 추천 도서 : GoF의 디자인 패턴(에릭 감마 외)
- 템플릿 메소드 패턴(template method pattern)
  - 수퍼클래스에 기본적인 로직의 흐름을 만들고， 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 디자인 패턴
- 팩토리 메소드 패턴(factory method pattern)
  - 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것.
    - UserDao의 getConnection( ) 메소드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드.
    - UserDao의 서브클래스의 getConnection( ) 메소드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법
  - ![image](https://user-images.githubusercontent.com/36880294/54140320-b83eff00-4466-11e9-8209-3441cacdb664.png)
- UserDao에 팩토리 메소드 패턴을 적용해서 getConnection( )을 분리합시다.
  - 여기서 중요한건 상속구조를 통해 성격이 다른 관심사항을 분리한 코드를 만들어내고 서로 영향을 덜 주도록 했는지를 이해하는 것
- But, 템플릿 메소드 패턴과 팩토리 메소드 패턴에도 단점이 있다?
  - 상속을 사용했다.
  - 만약 이미 UserDao가 다른 목적을 위해 상속을 사용하고 있다면?
    - 자바는 클래스의 다중상속을 허용하지 않는다.
  - 상속을 통한 상하위 클래스의 관계는 밀접하다.
    - 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다.
      - 슈퍼클래스 내부의 변경이 있을때 모든 서브클래스를 함께 수정하거나 다시 개발해야할 수도 있다.
      - 슈퍼클래스가 더 이상 변화하지 않도록 제약을 가해야 할지도 모른다.
  - 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점
    - 만약 UserDao 외의 DAO 클래스들이 계속 만들어진다면 그때는 상속을 통해서 만들어진 getConnection( )의 구현 코드가 매 DAO 클래스마다 중복

## 1.3 DAO의 확장
