
스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다.

### Junit 테스트 실행 방법
JUnitCore을 이용해 테스트를 실행하고 콘솔에 출력된 메세지를 보고 결과를 확인하는 방법은 가장 간단하지만 테스트의 수가 많아지면 관리하기 힘들어진다는 단점.

가장 좋은 방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것.

IDE
@Test가 들어있는 테스트 클래스를 선택한 뒤, 이클립스의 run 메뉴의 Run As 항목 중에서 JUnit Test를 선택하면 테스트가 자동으로 실행됨.
( JUnitCore를 이용할 때처럼 main() 메서드를 만들지 않아도 된다. )

테스트의 총 수행시간, 실행한 테스트의 수, 테스트 에러의 수, 테스트 실패의 수 확인 가능한 뷰를 제공함.
또한 어떤 테스트 클래스를 실행했는지도 알 수 있음.
테스트 클래스 내에 있는 @Test가 붙은 테스트 메서드의 이름도 모두 보여준다.
각 테스트 메서드와 클래스의 테스트 수행에 걸린 시간도 보여준다.

다시 테스트 실행하려면, Rerun Test버튼

JUnit은 한 번에 여러 테스트 클래스를 동시에 실행할 수도 있다.
이클립스에서는 소스 트리에서 특정 패키지를 선택하고 컨텍스트 메뉴의 Run As > JUnit Test 실행하면
해당 패키지 아래에 있는 모든 JUnit 테스트를 한 번에 실행해줌.
소스 폴더나 프로젝트 전체를 선택해서 모든 테스트를 한 번에 실행도 가능.
단축키 : Alt + Shift + X 와 T 순서대로 누른다.

### 빌드 툴
프로젝트의 빌드를 위해서 ANT나 Maven과 같은 빌드툴과 스크립트를 사용하고 있다면,
빌드 툴에서 제공하는 JUnit 플러그인이나 태스트를 이용해 JUnit 테스트를 실행할 수 있다.
테스트 실행 결과는 옵션에 따라서 HTML이나 텍스트 파일의 형태로 보기 좋게 만들어진다.

개발자 개인별 => IDE에서 JUnit 도구 활용
여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 경우 => 서버에서 모든 코드를 가져와 통합하고 빌드하 뒤에 테스트를 수행하는 것이 좋음. 이때는 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과를 메일등으로 통보받는 방법 사용.

### 테스트 결과의 일관성
테스트를 실행하면서 불편했던 일
UserDaoTest 테스트를 실행하기 전에 DB의 테이블 데이터를 모두 삭제해주는 것

즉, 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한다는 점.
반복적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 좋은 테스트가 아님.
(DB서버가 다운됐다거나 네트워크 장애로 DB접근이 안된다던가가 아니라 성공해야 마땅한 테스트가 실패하기도 하는 경우..)

테스트는 항상 동일한 결과를 내야한다.

가장 좋은 해결책은 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어주는 것.

일반적으로 테스트하기 전에 테스트 실행에 문제가 되지 않는 상태를 만들어주는 편이 좋다.
즉, 테스트 실행 이전에 해당 테스트가 아닌 다른 이유로 테이블에 데이터가 들어가 있는 경우가 있으므로
테스트 시작 전에 데이터를 삭제하도록 한다.

**단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다!**
> DB에 남아있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하고,
> 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다

### 포괄적인 테스트
테스트를 안 만드는 것도 위험한 일이지만, 성의 없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다.

특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.

### getCount() 테스트
테스트 메서드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋다.
JUnit은 하나의 클래스 안에 여러 개의 테스트 메서드가 들어가는 것을 허용한다.
> 단, @Test가 붙어있고 public 접근자가 있으며 리턴 값이 void 형이고 파라미터가 없다는 조건은 지키자!

User클래스에 한 번에 모든 정보를 넣을 수 있도록 이를 한 번에 설정 가능한 생성자를 만들자.
단, 자바빈의 규약을 따르는 클래스에 생성자를 명시적으로 추가했을 때는 파라미터가 없는 디폴트 생성자도 함께 정의해주는 것을 잊지말자! <== ??? 자바빈의 규약??

주의해야할 점
두개의 테스트가 어떤 순서로 실행될지는 알 수 없다는 것!
JUnit은 특정한 테스트 메서드의 실행 순서를 보장해주지 않는다.
따라서, 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.
모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야한다.

### addAndGet() 테스트 보완
get()이 파라미터로 주어진 id에 해당하는 사용자를 가져온 것인지, 그냥 아무거나 가져온 것인지 테스트에서 검증하지 못했다.

특정 id에 해당하는 값을 가져오는지 확인해보자.

### get() 예외 조건에 대한 테스트
get() 메서드에 전달된 id 값에 해당하는 사용자 정보가 DB에 없다면?

가능한 방법 두가지
1. null과 같은 특별한 값을 리턴
2. id에 해당하는 정보를 찾을 수 없다고 예외를 던지는 것

2번 방법
주어진 id에 해당하는 정보가 없다느 의미를 가진 예외 클래스가 하나 필요함.
스프링이 정의한 데이터 액세스 예외 클래스들 중 EmptyResultDataAccessException 예외를 이용해보자.

일반적으로 테스트 중에 예외가 던져지면 테스트 메서드의 실행은 중단되고 테스트는 실패함.
=> 테스트 에러

여기서는 테스트 진행 중에 특정 예외가 던져지면 테스트가 성공한 것이고,
예외가 던져지지 않고 정상적으로 작업을 마치면 테스트가 실패했다고 판단해야한다.
그런데, 예외 발생 여부는 메서드를 실행해서 리턴 값을 비교하는 방법으로 확인할 수 없다.
즉, AssertThat() 메서드로는 검증이 불가능함.

이런 경우를 위해 JUnit은 예외조건 테스트를 위한 특별한 방법 제공함.

존재하지 않는 id로 get()을 호출해보자.
=> 이때 EmptyResultDataAccessException이 던져지면 성공, 아니면 실패

```Java
JUnit의 예외 테스트 기능
예외가 반드시 발생해야 하는 경우를 테스트하고 싶을 때 유용하게 쓸 수 있다.

// 테스트 중에 발생할 것으로 기대하는 예외 클래스를 지정해준다.
@Test(expected = EmptyResultDataAccessException.class)
public void getUserFailure() throws SQLException {

}
```

테스트해보면 테스트실패함. 왜냐면 SQLException을 던져주기 때문임.
우리가 원하는 예외를 던져주도록 코드를 바꿔보자.

우선, User객체의 레퍼런스 변수user를 null 상태로 초기화해두고,
id를 조건으로 한 쿼리의 결과가 있으면 User 객체를 만들고 값을 넣어준다.
즉, 결과가 없으면 user는 null 상태다.

그러고서
```
if(user == null) throw new EmptyResultDataAccessException(1);
```

### 포괄적인 테스트
개발자가 테스트를 직접 만들 때 자주하는 실수
성공하는 테스트만 골라서 만드는 것.
개발자는 머릿속으로 이 코드가 잘 돌아가는 케이스를 상상하면서 코드를 만드는 경우가 일반적임.
그래서 테스트를 작성할 때도 문제가 될 만한 상황이나, 입력 값 등은 교묘히도 잘 피해서 코드를 만드는 습성이 있음.

=> QA팀이나 고객의 인수담당자에 의해 꼼꼼하게 준비된 시나리오를 따라 다양한 경우에 대한 전문적인 테스트가 필요한 이유임..

```
" 항상 네거티브 테스트를 먼저 만들라 "
                      - 스프링의 창시자 로드 존슨
```
테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이자.

### 테스트가 이끄는 개발
앞서 get()메서드의 예외 테스트를 만드는 과정의 작업 순서를 잘 생각해보자.
테스트를 먼저 만들어 테스트가 실패하는 것을 보고 나서 코드에 손을 댔다.
이런 순서를 따라서 개발을 진행하는 구체적인 개발 전략이 실제로 존재한다.

### 기능설계를 위한 테스트
추가하고 싶은 기능을 코드로 표현하려고 하면 됨.
예를 들면,
" 존재하지 않는 id로 get() 메서드를 실행하면 특정한 예외가 던져진다 "라는 기능

테스트 코드는 **잘 작성된 하나의 기능정의서**
테스트에는 만들고 싶은 기능에 대한 조건과 행위, 결과에 대한 내용이 잘 표현되어 있음.

보통 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능 설계에 해당하는 부분을 테스트가 일부분 담당하고 있다고도 볼 수 있다.

### 테스트 주도 개발
테스트 주도 개발( TDD, Test Driven Development ) 혹은 테스트 우선 개발( Test First Development )
: 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발방법

TDD의 기본원칙
" 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다."
=> 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있음.

가끔 Test를 만드는 걸 미루게 되는데
TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드므로 테스트를 빼먹지 않고 꼼꼼하게 만들 수 있다.

테스트 없이 한 번에 너무 많은 코드를 만드는 것은 좋지 않다.
까먹음 ..

TDD의 장점 중 하나는 코드를 만들어 테스트르 실행하는 그 사이 간격이 매우 짧다는 점.
> 서버에 올려서 테스트하면 코드 수정후에 다시 서버 재시작해야하는 느리고 지루한 과정 반복해야함

엔터프라이즈 애플리케이션의 테스트는 만들기가 매우 어려웠음.
But 스프링은 테스트하기 편리한 구조의 애플리케이션을 만들게 도와줄 뿐 아니라, 엔터프라이즈 애플리케이션 테스트를 빠르고 쉽게 작성할 수 있는 매우 편리한 기능을 많이 제공함.

### 테스트 코드 개선
애플리케이션 코드만 리팩토링 대상인게 아니다.
테스트 코드를 리팩토링해보자.

기계적으로 반복되는 부분
스프링의 애플리케이션 컨텍스트를 만드는 부분과 컨텍스트에서 UserDao가져오는 부분
=> 중복된 코드는 별도의 메서드로 뽑아낸다. (메서드 추출 리팩토링 방법이 가장 손쉬운 방법임.)

BUT!! JUnit이 제공하는 기능을 활용해보자.
JUnit 프레임워크는 테스트 메서드를 실행할 때 부가적으로 해주는 작업이 몇가지 있음.
그중
테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메서드에 넣게 해주고,
이를 매번 테스트 메서드를 실행하기 전에 먼저 실행시켜주는 기능이 있다.

####JUnit 프레임워크가 테스트 메서드를 실행하는 과정
프레임워크는 스스로 제어권을 가지고 주도적으로 동작하고, 개발자가 만든 코드는 프레임워크에 의해 수동적으로 실행된다.
```
JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식
1. 테스트 클래스에서 @Test가 붙은 public 이고 void형이며 파라미터가 없는 테스트메서드를 모두 찾는다.

2. 테스트 클래스의 오브젝트를 하나 만든다.

3. @Before가 붙은 메서드가 있으면 실행한다.

4. @Test가 붙은 메서드를 하나 호출하고 테스트 결과를 저장해둔다.

5. @After가 붙은 메서드가 있으면 실행한다.

6. 나머지 테스트 메서드에 대해 2~5번을 반복한다.

7. 모든 테스트의 결과를 종합해서 돌려준다.
```
실제로는 이보다 더 복잡함.

보통 하나의 테스트 클래스 안에 있는 테스트 메서드들은 공통적인 준비작업과 정리작업이 필요한 경우가 많다.
이런 작업들을 @Before, @After가 붙은 메서드에 넣어두면 JUnit이 자동으로 메서드를 실행해주니 매우 편리하다. **각 테스트 메서드에서 직접 setUp()과 같은 메서드(@Before 붙였던)를 호출할 필요도 없다.**
대신 직접 호출하지 않기 때문에 서로 주고받을 정보나 오브젝트가 있다면 인스턴스 변수를 이용해야 한다.

#### 또 하나 기억할 점!
각 테스트 메서드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다는 점.
한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메서드를 사용하고 나면 버려진다.

즉, 테스트 클래스가 @Test 테스트 메서드를 두 개 갖고 있다면, 테스트가 실행되는 중에 JUnit은 이 클래스의 오브젝트를 두 번 만들 것임.

왜 (테스트 메서드를 실행할 때마다 새로운 오브젝트를 만드는가) ?
그냥 테스트 클래스마다 하나의 오브젝트만 만들어놓고 사용하는 편이 성능도 낫고 더 효율적이지 않음?
JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 **확실히 보장해주기 위해** 매번 새로운 오브젝트를 만들게 했다. 덕분에 인스턴스 변수도 부담없이 사용할 수 있음.(어차피 다음 테스트 메서드가 실행될 때는 새로운 오브젝트가 만들어져서 다 초기화될테니까..)

그렇다면,
테스트 메서드 **전부** 에 공통적으로 사용되는 코드가 아니라 **일부** 에서만 공통적으로 사용하는 코드가 있다면 ?
@Before을 사용하기보다는 일반적인 메서드 추출 방법을 써서 메서드를 분리하고 테스트 메서드에서 직접 호출해 사용하도록 만드는 편이 낫다.
아니면 아예 공통적인 특징을 지닌 테스트 메서드를 모아서 별도의 테스트 클래스로 만들던지

### 픽스처
픽스처 fixture
: 테스트를 수행하는 데 필요한 정보나 오브젝트.
: 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before메서드를 이용해 생성해두면 편리함.
예> UserDaoTest에서라면 dao가 대표적인 픽스처임. 테스트 중에 add() 메서드에 전달하는 User 오브젝트들도 픽스처임.



#### @Before
