UserDaoTest의 두가지 문제점 개선하기

### 테스트 검증의 자동화

테스트 결과에 대해..

**테스트 에러 :**
테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우
> 쉽게 확인 가능.
> 콘솔에 에러 메시지와 긴 호출 스택 정보가 출력됨.

**테스트 실패 :**
테스트 작업 중에 에러가 발생하진 않았지만 그 결과가 기대한 것과 다르게 나오는 경우
> 별도의 확인 작업과 그 결과가 있어야만 알 수 있음.


테스트의 수행과 테스트 값 적용, 그리고 결과를 검증하는 것까지 모두 자동화 할 수 있다.

```
"테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것"
                                - 자동화된 테스트를 위한 xUnit 프레임워크를 만든 켄트 벡
```

### 테스트의 효율적인 수행과 결과 관리

일정한 패턴을 가진 테슽를 만들 수 있고,
많은 테스트를 간단히 실행시킬 수 있으며,
테스트 결과를 종합해서 볼 수 있고,
테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘 테스트 지원도구와
그에 맞는 테스트 작성 방법이 필요하다.

자바에는 단순하면서도 실용적인 테스트를 위한 도구가 여러가지 존재함.
그중 **프로그래머를 위한 자바 테스팅 프레임워크** 라고도 불리는 **JUnit** 은 유명한 테스트 지원도구임.

JUnit은 프레임워크다.
```
1장에서 프레임워크의 기본 동작원리가 바로 제어의 역전IoC라고 했다.
프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다.

개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다.
따라서 프레임워크에서 동작하는 코드는 main() 메서드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.
```

따라서, 기존의 main() 메서드 테스트는 프레임워크에 적용하기엔 적합하지 않다.
( 테스트가 main() 메서드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이므로..)

1
main()메서드에 있던 테스트 코드를 일반 메서드로 옮기자.
새로만들 테스트 메서드는 **JUnit 프레임워크가 요구하는 조건 두가지** 를 따라야 한다.
1. 메서드가 public으로 선언돼야 한다.
2. 메서드에 @Test라는 어노테이션을 붙여주는 것
+ 메서드 이름은 이왕이면 테스트의 의도가 무엇인지 알 수 있는 이름이 좋다.

2
테스트의 결과를 검증하는 if/else 문장을 JUnit이 제공하는 방법을 이용해 전환해보자.
```java
if (!user.getName().equals(user2.getName())) { ... }


↓ JUnit이 제공해주는 assertThat이라는 static 메서드를 이용해보자.

assertThat(user2.getName(), is(user.getName()));
// 첫 번째 파라미터의 값을 뒤에 나오는 매처matcher라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다.

// is()는 매처의 일종으로 equals()로 비교해주는 기능을 가진다.
```

### JUnit 테스트 실행
스프링 컨테이너와 마찬가지로 JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야한다.

JUnit은 assertThat()을 이용해 검증을 했을 때 기대한 결과가 아니면 AssertionError를 던진다.
( java.lang.AssertionError를 던짐 )
