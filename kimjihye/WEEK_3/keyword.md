#### 마이크로 DI
의존관계 주입DI은 다양한 형태로 적용이 가능함

제 3자의 도움을 통해
두 오브젝트 사이의 유연한 관계가 설정되도록 만든다.
=> 이 개념만 따르면 DI를 이루는 오브젝트와 구성요소의 구성과 관계는 디양하게 만들 수 있다.

DI는 일반적으로 아래 4개의 오브젝트 사이에서 일어난다.
 - 의존관계에 있는 두 개의 오브젝트 ( 전략interface를 구현하는 구현체들)
 - 두 오브젝트의 관계를 dynamic하게 설정해주는 오브젝트 팩토리(DI 컨테이너)
 - 이를 사용하는 클라이언트

 하지만 때로는 원시적인 전략 패턴 구조를 따라 client가 오브젝트 팩토리의 책임을 함께 지기도 한다.
 ![DI structure as a strategy pattern](../images/strategy_pattern2.PNG)

 혹은 client와 전략(의존 오브젝트)이 결합될 수도 있다.
 client와 DI관계에 있는 두 개의 오브젝트가 모두 하나의 클래스안에 담길 수도 있다.
 => 이런 경우 DI가 매우 작은 단위의 코드와 메서드 사이에서 일어나기도 한다. 이때는 얼핏보기엔 DI같아 보이지 않지만, 세밀하게 관찰하면 작은 단위지만 엄연히 DI가 이뤄지고 있음을 알 수 있다.

 이렇게 DI의 장점을 단순화해서 IoC컨테이너의 도움 없이 코드 내에서 적용한 경우를 **마이크로 DI** 라고 한다. 또는 **코드에 의한 DI라는 의미** 로 **수동 DI** 라고도 함.


#### 중첩 클래스의 종류
중첩 클래스 nested class : 다른 클래스 내부에 정의되는 클래스.
  - 독립적으로 오브젝트로 만들어질 수 있는 **static class**

  - 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 **inner class** (내부 클래스)
    => 범위(scope)에 따라 세 가지로 구분됨
    - member inner class : 멤버 필드처럼 오브젝트 레벨에 정의됨.
    - local class : 메서드 레벨에 정의됨. **
    - anonymous inner class : 이름을 갖지 않음. 선언된 위치에 따라서 범위가 달라진다.

#### 익명 내부 클래스
이름을 갖지 않는 클래스다.
클래스 선언과 오브젝트 생성이 결합된 형태로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용한다.
- 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.

new 인터페이스이름() { 클래스 본문 };

#### 템플릿
어떤 목적을 위해 미리 만들어둔 모양이 있는 틀.
프로그래밍에서는 고정된 틀 안에 바꿀수 있는 부분을 넣어서 사용하는 경우에 템플릿이라고 부른다.
> JSP는 HTML이라는 고정된 부분에 EL과 스크립릿이라는 변하는 부분을 넣은 일종의 템플릿 파일이다.

템플릿 메서드 패턴은 고정된 틀의 로직을 가진 템플릿 메서드를 슈퍼클래스에 두고, 바뀌는 부분을 서브클래스의 메서드에 두는 구조로 이뤄진다.

#### 콜백
콜백은 실행되는 것을 목적으로 다른 오브젝트의 메서드에 전달되는 오브젝트를 말한다.
파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 **특정 로직을 담은 메서드를 실행시키기 위해 사용** 한다. 자바에선 메서드 자체를 파라미터로 전달할 방법은 없기 때문에 메서드가 담긴 오브젝트를 전달해야한다. 그래서 functional object라고도 한다.
