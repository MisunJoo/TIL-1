**DAO의 확장**

모든 오브젝트는 변한다. 그러나 그 변화의 성격은 다르다.
= 변화의 이유와 시기, 주기 등이 다르다
```
예>
UserDao의 관심

JDBC API를 사용할 것인가
DB전용 API를 사용할 것인가
어떤 테이블 이름과 필드 이름을 사용해 어떤 SQL을 만들 것인가
어떤 오브젝트를 통해 DB에 저장할 정보를 전달받고 DB에서 꺼내온 정보를 저장해서 넘겨줄 것인가

이러한 관심사가 바뀌면 코드가 바뀐다.
```

상속보다 좀 더 확실한 방법으로 클래스를 분리해보자.
상속관계도 아닌 완전히 독립적인 클래스로 만들고, 이를 이용하게 만든다.

이떄, 상속을 이용했을 때와 마찬가지로 자유로운 확장이 가능하게 하려면 두 가지 문제를 해결해야 한다.
1 메서드명 변경될 수 있다는 것
2 DB커넥션을 제공하는 클래스가 어떤 것인지 구체적으로 알고있어야 함
근본 원인 > UserDao가 바뀔 수 있는 정보에 대해 너무 많이 알고 있어서 => 종속 ↑

#### 인터페이스 도입

두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어 준다.
> 추상화 : 어떤 것들의 공통적인 성겨을 뽑아내어 이를 따로 분리해내는 작업.

인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이다.
어떻게 하겠다는 구현 방법은 나타나 있지 않다.

여전히 UserDao에는 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 코드가 남아있다.
=> 분리되지 않은 또다른 관심사항이 존재하고 있기 때문

#### 관계설정 책임의 분리
분리되지 않은 관심사 : UserDao가 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할 지 결정하는 것.

UserDao와 ConnectionMaker의 특정 구현 클래스 사이의 관계를 결정해주는 것에 대한 관심!

UserDao의 클라이언트 오브젝트가
UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해주는 기능을
분리해서 두기에 적절한 곳이다.
> 클라이언트 - 서비스 ( 두 개의 오브젝트가 있을 때, 한 오브젝트가 다른 오브젝트의 기능을 사용하면 사용되는 오브젝트를 서비스, 사용하는 오브젝트를 클라이언트라 부를 수 있다.)


오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.
```java
DConnectionMaker의 오브젝트의 레퍼런스를 UserDao의 connectionMaker변수에 넣어서 사용하게 함으로써, 이 두 개의 오브젝트가 '사용'이라는 관계를 맺게 해준다.

connectionMaker = new DConnectionMaker();
```

오브젝트 사이의 관계가 만들어지려면 일단 만들어진 오브젝트가 있어야 한다.
직접 생성자를 호출해서 오브젝트를 만드는 방법도 있지만

외부에서 만들어준 것을 가져오는 방법도 있다.
> 메서드 파라미터나 생성자 파라미터를 이용해 전달할 수 있음.

이때 파라미터의 타입을 전달받을 오브젝트의 **인터페이스** 로 선언한다.
그러면 파라미터로 전달되는 오브젝트 클래스는 해당 인터페이스를 구현하기만 했다면 어떤 것이든 상관없어짐.
또한 파라미터로 제공받은 오브젝트는 인터페이스에 정의된 메서드만 이용한다면 어떤 클래스로부터 만들어졌는지 신경쓰지 않아도 됨.
=> 객체지향 프로그램의 다형성이라는 특징 덕분.

클래스 사이의 관계는 코드에 다른 클래스의 이름이 나타나기 때문에 만들어지는 관계.

오브젝트 사이의 관계는 특정 클래스를 전혀 알지 못하더라도 인터페이스를 통해 받아서 사용가능.
런타임 시점에 관계가 형성됨. 런타임 오브젝트 의존관계.

이러한 런타임 오브젝트 관계를 만들어주는 것은 UserDao의 클라이언트가 책임.
클라이언트는 자기가 UserDao를 사용해야 할 입장이기 때문에 UserDao의 세부전략이라고도 볼 수 있는 ConnectionMaker의 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성해서 UserDao와 연결해줄 수 있다.

이제 UserDao의 관심사는``` 사용자 데이터 액세스 작업을 위해 SQL을 생성하고, 이를 실행하는 것```
에만 집중할 수 있다.

DB생성 방법이나 전략을 고민할 필요도 없고, DB커넥션을 가져오는 방법의 변경에 영향받지 않음.

#### 개방 폐쇄 원칙
OCP, Open-Closed Principle
클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다

인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 개방되어 있다.
반면 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다.

인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 이 개방 페쇄 원칙을 따른다고 볼 수 있다.

#### 높은 응집도와 낮은 결합도
high coherence and low coupling

응집도가 높다 = 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다.
높은 응집도는 클래스 레벨뿐 아니라, 패키지, 컴포넌트, 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있다.

**높은 응집도**
응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 있다.
즉 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있다.

**낮은 결합도**
책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.
하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도
결합도가 높아지면 변경에 따르는 작업량이 많아지고, 변경으로 인해 버그가 발생할 가능성이 높아진다.

#### 전략 패턴 Strategy Pattern
> 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴이다.

**전략패턴** 은 자신의 기능 맥락(context)에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로
분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴.
> 여기서 알고리즘이란 수학적 알고리즘 X, 독립적인 책임으로 분리가 가능한 기능 O
> 이를 대체 가능한 전략이라고 보기 때문에 패턴의 이름이 전략 패턴임.

UserDao는 전략 패턴의 컨텍스트에 해당함.

컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한, DB연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고
이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있다.

전략패턴은 UserDaoTest와 같은 클라이언트의 필요성에 대해서도 잘 설명하고 있다.
전략 패턴의 적용 방법을 보면 클라이언트의 역할이 잘 설명되어 있다.
컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략(ConnectionMaker를 구현한 클래스, DConnectionMaker)을
컨텍스트의 생성자등을 통해 제공해주는게 일반적이다.

# 스프링이란 지금까지 설명한 객체지향적 설계 원칙과 디자인 패턴에 나타난 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임워크다.
