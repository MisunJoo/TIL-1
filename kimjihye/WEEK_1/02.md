**DAO의 분리**

객체지향에서는 모든 것이 변한다.
여기서 변한다는 것은 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻.
> 사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다.
> 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀐다.
> 운영되는 환경도 변화한다.

따라서, 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 **미래의 변화를 어떻게 대비할 것인가** 다.

객체지향 기술은 흔히 실세계를 최대한 가깝게 모델링해낼 수 있기 때문에 의미가 있다고 여겨진다.
하지만 그보다는 객체지향이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고
편리하게 변경, 발전, 확장시킬 수 있다는 데 더 의미가 있다. 변화에 효과적으로 대처할 수 있다는 기술적인 특징.
변경이 나머지 기능에 문제를 일으키지 않는 것.

분리와 확장을 고려한 설계 => 변경이 일어날 때 필요한 작업을 최소화하고, 다른 곳에 문제를 일으키지 않음.

분리

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
문제는, 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다.

변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다.
즉, 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

####관심사의 분리 Separation of Concerns

이를 객체지향에 적용해보면, 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고,
관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것.

커넥션 만들기의 추출

Dao의 관심사항
1
- DB와 연결을 위한 **connection을 어떻게 가져올까** 라는 관심
- 어떤 DB를 쓰고, 어떤 드라이버를 사용할 것이고, 어떤 로그인 정보를 쓰는데, 그 connection을 생성하는 방법은 또 어떤 것이다
2
- 사용자 등록을 위해 DB에 보낼 SQL문장을 담을 Statement를 만들고 실행하는 것
- 파라미터로 넘어온 사용자 **정보를 Statement에 바인딩** 시키고, Statement에 **담긴 SQL을 DB를 통해 실행시키는 방법**
3
- 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘서 소중한 공유 리소스를 시스템에 돌려주는 것

가능한 방법(?)


1
- 추상메서드로 선언해서 사용하는 쪽에서 원하는 방식으로 확장하도록 한다.
- **상속** 을 통해 서브클래스로 분리하는 것.

템플릿 메서드 패턴
super 클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를
추상메서드나 오버라이딩이 가능한 protected 메서드 등으로 만든 뒤 서브클래스에서 이런 메서드를 필요에 맞게
구현해서 사용하도록 하는 방법

public class UserDao
```Java
Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메서드

public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
```
public class NUserDao extends UserDao
```Java
어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지(각자의 생성 알고리즘)를 결정하는 방법을 구현해 놓은 서브클래스(NUserDao)의 메서드

각자의 생성알고리즘이라는 건 예를 들면, 커넥션을 서버의 DB커넥션 풀에서 가져올 지, 드라이버를 직접 이용해서 새로운 DB커넥션을
만들지 등등

public Connection getConnection() throws ClassNotFoundException, SQLException{
      Class.forName("com.mysql.cj.jdbc.Driver");
      // JDBC가 정의한 Connection 인터페이스를 구현한 Connection 오브젝트를 만들어낸다.
      Connection c = DriverManager.getConnection("jdbc:mysql://localhost/~","~","~");
      return c;
}

=> 리턴되는 Connection 오브젝트를 받는 UserDao는 이러한 Connection의 구현 방법에는 관심이 없음.
그저 Connection 인터페이스 타입의 오브젝트라는 것 만 인지하고, Connection 인터페이스에 정의된 메서드를 사용할 뿐임.
```
팩터리 메서드 패턴이라고도 할 수 있음.
(마찬가지로 상속을 통해 기능을 확장하게 하는 패턴이므로 템플릿메서드 패턴과 구조도 비슷.)

=> 그러나 이 역시도 문제점이 있음.
0
자바는 클래스의 다중상속을 허용하지 않는다.
만약 해당 Dao가 다른 목적을 위해 상속을 이미 사용하고 있다면?
또는 후에 다른 목적으로 Dao에 상속을 적용하려 한다면?
등의 한계가 있다.
1
상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다.
상속관계는 두 가지 다른 관심사에 대해 **긴밀한** 결합을 허용한다.
서브 클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다.
그래서 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.
반대로 그런 변화에 따른 불편을 주지 않기 위해 슈퍼클래스가 더 이상 변화하지 않도록 제약을 가하게 될지도 모름.
2
만약 DAO클래스들이 여러개 만들어진다면 매 DAO클래스마다 DB커넥션을 생성하는 getConnection() 구현코드가 또 다시 중복됨.

예외 상황에 대한 처리
수많은 동시 사용자가 있고, 한번 시작되면 장기간 운용되는 서버에 올라간다면 예외상황에 적절하게 대응해서 공유 리소스를
반환하지 않는 일이 없도록 세심하게 주의해야 한다.
