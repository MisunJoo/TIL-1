**싱글톤 레지스트리와 오브젝트 스코프**
(싱글톤 저장소로서의 IoC컨테이너 스프링의 특징을 알아보자)

스프링의 애플리케이션 컨텍스트는 기존에 직접 만들었던 오브젝트 팩토리와 중요한 차이가 있음.

두 개의 오브젝트가 동일하다면 사실은 한 개의 오브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐임.

> 오브젝트별로 할당되는 고유한 값이 있음.

오브젝트 팩토리
DaoFactory의 userDao()를 여러번 호출했을 때 동일한 오브젝트가 돌아오는가 ?  NO
  코드를 보면 매번 userDao() 메서드를 호출할 때마다 new 연산자에 의해 새로운 오브젝트가 만들어지게 되어 있음.

어플리케이션 컨텍스트
getBean()을 여러번 호출했을 때 동일한 오브젝트가 돌아오는가 ? YES

동작방식에 차이가 있음.
스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다는 것.

###싱글톤 레지스트리로서의 애플리케이션 컨텍스트

애플리케이션 컨텍스트
= 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC컨테이너 + 싱글톤을 저장하고 관리하는 싱글톤 레지스트리singleton registry

스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.
> 디자인 패턴에 나오는 싱글톤 패턴과 비슷한 개념이지만 구현 방법은 확연히 다름!

####스프링이 빈을 싱글톤으로 만드는 이유?
서버 애플리케이션과 싱글톤

스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이므로
태생적으로 스프링은 엔터프라이즈 시스템을 위해 고안된 기술이기 때문에 서버 환경에서 사용될 때 그 가치가 있음.
실제로도 스프링은 대부분 서버환경에서 사용됨.

스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었음.
하나의 요청을 처리하기 위해 데이터 액세스로직, 서비스 로직, 비즈니스 로직, 프레젠테이션 로직 등의
다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조로 이뤄진 경우가 대부분임.
비즈니스 로직도 복잡한 경우가 많음.

그런데 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 해보자.
요청 한 번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면, 초당 2500개의 새로운 오브젝트가 생성된다.
1분이면 오만 개, 한 시간이면 9백만 개의 새로운 오브젝트가 만들어진다. 아무리 자바의 오브젝트 생성과 가비지 컬렉션 GC 의 성능이
좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.

엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다.
서브릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 있음.
서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다.
서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

이렇게 **애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리**
따라서 서버환경에서는 서비스 싱글톤의 사용이 권장됨.

하지만 디자인 패턴에 소개된 싱글톤 패턴은 사용하기가 까다롭고 여러 가지 문제점이 있다.
> 피해야 할 패턴이라는 의미로 안티패턴이라고 부르는 사람도 있음.

#### 싱글톤 패턴의 한계

자바에서 싱글톤을 구현하는 방법
- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입(자료형)의 static 필드를 정의한다.
- static factory 메서드인 getInstance()를 만들고 이 메서드가 최초로 호출되는 시점에서 한번만 오브젝트가
  만들어지게 한다. 생성된 오브젝트는 static field에 저장된다. 또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다.
- 한번 오브젝트(싱글톤)가 만들어지고 난 후에는 getInstance()메서드를 통해 이미 만들어져 static field에
  저장해둔 오브젝트를 넘겨준다.

```java
  public static synchronized UserDao getInstance() {
    if(INSTANCE == null) INSTANCE = new UserDao();
    return INSTANCE;
  }

  synchronized있어서 INSTANCE가져올 때는 방해받지 않는다 쳐도
  가져오고 나서 그다음에 또 누가 가져오려고 하면 어떻게 됨>??
```

1. private 생성자를 갖고 있기 때문에 상속할 수 없다
싱글톤 패턴은 생성자를 private으로 제한한다. 오직 자신만이 자기 오브젝트를 만들도록 제한하는 것.
**문제는 private생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능하다는 점!**
따라서, 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없음.
기술적인 서비스만 제공하는 경우면 상관 없지만
애플리케이션의 로직을 담고 있는 읿반 오브젝트의 경우 싱글톤으로 만들었을 때 객체지향적인 설계의 장점을 적용하기가 어렵다
```
상속과 다형성 같은 객체지향의 특징이 적용되지 않는 static 필드와 메서드를 사용하는 것도 역시 동일한 문제.???
```

2. 싱글톤은 테스트하기가 힘들다
싱글톤은 만들어지는 방식이 제한적이기 떄문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다.
싱글톤은 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 다이나믹하게 주입하기도 힘들기 때문에
필요한 오브젝트는 직접 오브젝트를 만들어 사용할 수밖에 없다. 이런 경우 테스트용 오브젝트로 대체하기 힘듦.

테스트는 엔터프라이즈 개발의 핵심인데 애플리케이션 코드를 싱글톤으로 만들면 테스트를 만드는 데 지장이 있다는 건 큰 단점.

3. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다
서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.(?)

따라서 자바 언어를 이용한 싱글톤 패턴 기법은 서버환경에서는 싱글톤이 꼭 보장된다고 볼 수 없다.
여러 개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.

4. 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다
싱글톤은 사용하는 클라이언트가 정해져 있지 않다.
싱글톤의 static 메서드를 이용해 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 애플리케이션 어디서든지 사용될 수 있고, 그러다 보면
자연스럽게 전역 상태로 사용되기 쉽다. 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는
권장되지 않는 프로그래밍 모델이다.

###싱글톤 레지스트리
스프링은 서버 환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것은 적극 지지한다.
하지만 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다
그것이 바로 싱글톤 레지스트리 singleton registry다.

스프링 컨테이너는 싱글톤을 생성하고, 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다.
싱글톤 레지스트리의 장점은 스태틱 메서드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다.

평범한 자바 클래스라도 IoC방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면
손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.

오브젝트 생성에 관한 모든 권한은 IoC기능을 제공하는 애플리케이션 컨텍스트에게 있기 때문이다.

스프링의 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있다.
싱글톤으로 사용돼야 하는 환경이 아니라면 간단히 오브젝트를 생성해서 사용할 수 있다.
따라서 테스트환경에서 자유롭게 오브젝트를 만들 수 있고, 테스트를 위한 목 오브젝트로 대체하는 것도 간단하다.

**싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인패턴등을 적용하는데 아무런 제약이 없다.**

스프링은 IoC 컨테이너일 뿐만 아니라, 고전적인 싱글톤 패턴을 대신해서 싱글톤을만들고 관리해주는 싱글톤 레지스트리라는 점.
스프링이 빈을 싱글톤으로 만드는 것은 결국 오브젝트의 생성방법을 제어하는 IoC컨테이너로서의 역할.

만약 스프링 없이 DaoFactory만 사용한다면 이렇게 싱글톤 방식으로 UserDao를 한 번만 만들어두고 매번 같은 오브젝트를 리턴하게 사용하려면
DaoFactory가 상당히 지저분해질 것이다. ???? 구체적인 코드 보고싶으미

#### 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다.
따라서 상태관리에 주의를 기울여야함.

기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는
상태정보를 내부에 갖고 있지 않은 무상태stateless방식으로 만들어져야 함.
다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험하다.
저장할 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 떄문이다.
따라서 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지stateful방식으로 만들지 않는다.
이를 지키지 않으면 서버에 배포되고 여러 사용자가 동시에 접속하면 데이터가 엉망이 돼버리는 등의 심각한 문제가 발생함.
물론 읽기 전용의 값이라면 초기화 시점에서 인스턴스 변수에 저장해두고 공유하는 것은 아무문제없음.

**상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나, DB나 서버의 리소스로부터 생성한 정보는 어떻게 다뤄야 할까?**
=> 파라미터와 로컬 변수, 리턴 값등을 이용하면 됨. 메서드 파라미터나 메서드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이
만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸일은 없다.

개별적으로 바뀌는 정보는 로컬변수로 정의하거나, 파라미터로 주고받으면서 사용한다.
읽기 전용의 정보는 인스턴스 변수를 사용해도 상관없다.

단순한 읽기전용 값이라면 static final 이나 final로 선언하는 편이 나음.
#### 스프링 빈의 스코프
스프링이 관리하는 오브젝트(빈)가 생성되고, 존재하고, 적용되는 범위 = bean의 스코프 scope

스프링 빈의 기본 스코프는 싱글톤

싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안
계속 유지된다. 스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 가짐.

경우에 따라서 싱글톤 외의 스코프를 가질 수 있음.
대표적으로 프로토타입prototype 스코프가 있음.
> prototype 스코프
> 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다.

> request 스코프
> 웹을 통해 새로운 HTTP 요청이 생길때마다 생성되는 요청스코프

> session 스코프
> 웹의 세션과 스코프가 유사한 세션 스코프

이 외에도 다양한 스코프가 있음.
